(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{753:function(e,i,a){"use strict";a.r(i);var t=a(5),n=Object(t.a)({},(function(){var e=this,i=e.$createElement,a=e._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"如何做启动优化-如何监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做启动优化-如何监控"}},[e._v("#")]),e._v(" 如何做启动优化，如何监控")]),e._v(" "),a("p",[e._v("iOS启动优化是提升应用程序启动速度和响应性能的一系列技术和方法。下面是一些常用的iOS启动优化方法和监控工具：\n启动优化方法：")]),e._v(" "),a("h2",{attrs:{id:"减少冷启动时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少冷启动时间"}},[e._v("#")]),e._v(" 减少冷启动时间：")]),e._v(" "),a("p",[e._v("冷启动是指应用进程不在系统中，需要系统分配新的进程来启动应用。为了减少冷启动时间，可以考虑以下优化方法：")]),e._v(" "),a("ol",[a("li",[e._v("合并动态库并减少使用Embedded Framework。")]),e._v(" "),a("li",[e._v("删除无用代码并抽取重复代码。")]),e._v(" "),a("li",[e._v("避免在+load方法中执行耗时操作，使用+initialize代替。")]),e._v(" "),a("li",[e._v("避免使用attribute((constructor))，可将要实现的内容放在初始化方法中配合dispatch_once使用。")]),e._v(" "),a("li",[e._v("减少非基本类型的C++静态全局变量的个数。")])]),e._v(" "),a("h2",{attrs:{id:"优化main函数代理阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化main函数代理阶段"}},[e._v("#")]),e._v(" 优化main函数代理阶段：")]),e._v(" "),a("p",[e._v("main函数代理阶段是指从main()函数开始执行到didFinishLaunchingWithOptions方法执行结束的耗时。在这个阶段可以考虑以下优化方法：")]),e._v(" "),a("ol",[a("li",[e._v("删除不必要的初始化代码。")]),e._v(" "),a("li",[e._v("延迟加载不必要的模块和功能。")]),e._v(" "),a("li",[e._v("使用异步加载和懒加载来提高启动速度。")])]),e._v(" "),a("h1",{attrs:{id:"监控工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控工具"}},[e._v("#")]),e._v(" 监控工具：")]),e._v(" "),a("ol",[a("li",[e._v("Xcode Instruments：Xcode自带的性能分析工具，可以使用Time Profiler和System Trace等工具来监控应用程序的启动时间和性能。")]),e._v(" "),a("li",[e._v("DYLD_PRINT_STATISTICS：通过设置环境变量DYLD_PRINT_STATISTICS或DYLD_PRINT_STATISTICS_DETAILS，可以在Xcode中查看应用程序启动过程中各个阶段的耗时统计信息。")])]),e._v(" "),a("p",[e._v("以上是一些常用的iOS启动优化方法和监控工具，通过优化启动流程和使用合适的工具，可以提升应用程序的启动速度和响应性能。")]),e._v(" "),a("h1",{attrs:{id:"如何做卡顿优化-如何监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做卡顿优化-如何监控"}},[e._v("#")]),e._v(" 如何做卡顿优化，如何监控")]),e._v(" "),a("p",[e._v("iOS卡顿优化方法可以从两个方面入手：CPU优化和GPU优化。下面将介绍一些常用的优化方法，并提供一些监控工具供参考。")]),e._v(" "),a("h2",{attrs:{id:"cpu优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu优化方法"}},[e._v("#")]),e._v(" CPU优化方法：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("减少计算量：\n提前计算好布局，避免在显示时进行复杂的计算 [1].\n使用轻量级对象，如CALayer代替UIView，避免不必要的事件处理 [1].\n避免重复执行的方法，如多个地方监听同一个通知，通知中执行多次的清除缓存的方法 [1].\n将耗时的操作放到子线程，避免阻塞主线程 [1].\n将文本处理放在子线程进行，如文本尺寸计算和绘制 [1].")])]),e._v(" "),a("li",[a("p",[e._v("图片解码优化：\n使用SDWebImage等库，在后台线程将图片绘制到CGBitmapContext中，然后直接从Bitmap创建图片 [1].")])])]),e._v(" "),a("h2",{attrs:{id:"gpu优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpu优化方法"}},[e._v("#")]),e._v(" GPU优化方法：")]),e._v(" "),a("ol",[a("li",[e._v("减少渲染量：")])]),e._v(" "),a("p",[e._v("合并多张图片为一张图片显示，减少短时间内大量图片的显示 [1].\n控制纹理尺寸不超过4096*4096，避免占用CPU资源进行处理 [1].\n减少视图数量和层次，避免混合过程中消耗CPU资源 [1].\n尽量使用不透明的视图，设置opacity为YES，避免alpha通道的合成 [1].\n避免离屏渲染，如光栅化、遮罩、圆角等操作 [1].")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("画圆角避免离屏渲染：")])]),e._v(" "),a("p",[e._v("使用CAShapeLayer与UIBezierPath配合画圆角 [1].")]),e._v(" "),a("h1",{attrs:{id:"监控工具-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控工具-2"}},[e._v("#")]),e._v(" 监控工具：")]),e._v(" "),a("ol",[a("li",[e._v("Instruments：Xcode自带的性能分析工具，可以监控CPU、内存、网络等性能指标，帮助定位卡顿问题.")]),e._v(" "),a("li",[e._v("FPS监控：通过在App中添加FPS监控代码，可以实时监测帧率，判断是否存在卡顿.")]),e._v(" "),a("li",[e._v("卡顿检测工具：如Facebook的Chisel、Tencent的GT等，可以监测主线程卡顿情况，并提供详细的卡顿堆栈信息.")])]),e._v(" "),a("p",[e._v("以上是一些常用的iOS卡顿优化方法和监控工具")]),e._v(" "),a("h1",{attrs:{id:"fps-用-cadisplaylinker-来计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fps-用-cadisplaylinker-来计数"}},[e._v("#")]),e._v(" FPS 用 CADisplayLinker 来计数")]),e._v(" "),a("p",[e._v("使用CADisplayLink来计算FPS的步骤如下：")]),e._v(" "),a("ol",[a("li",[e._v("创建CADisplayLink对象，并将其添加到当前的run loop中的NSRunLoopCommonModes中。这样可以确保CADisplayLink在屏幕刷新时被调用。")]),e._v(" "),a("li",[e._v("在CADisplayLink的回调方法中，记录每次调用的次数，并计算时间间隔。")]),e._v(" "),a("li",[e._v("当时间间隔超过1秒时，计算FPS并进行相应的处理（例如打印、显示在界面上等）。")]),e._v(" "),a("li",[e._v("重置计数和时间戳，以便下一次计算。")])]),e._v(" "),a("p",[e._v("以下是一个示例代码：")]),e._v(" "),a("p",[e._v("import UIKit\nclass ViewController: UIViewController {\nvar displayLink: CADisplayLink?\nvar frameCount = 0\nvar timestamp = 0.0")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('override func viewDidLoad() {\n    super.viewDidLoad()\n    setupDisplayLink()\n}\n\nfunc setupDisplayLink() {\n    displayLink = CADisplayLink(target: self, selector: #selector(update))\n    displayLink?.add(to: .current, forMode: .common)\n}\n\n@objc func update() {\n    if timestamp == 0 {\n        timestamp = displayLink?.timestamp ?? 0\n        return\n    }\n\n    frameCount += 1\n    let elapsed = displayLink?.timestamp ?? 0 - timestamp\n\n    if elapsed >= 1.0 {\n        let fps = Double(frameCount) / elapsed\n        print("FPS: \\(fps)")\n\n        // Reset\n        frameCount = 0\n        timestamp = displayLink?.timestamp ?? 0\n    }\n}\n')])])]),a("p",[e._v("}")]),e._v(" "),a("p",[e._v("这段代码创建了一个CADisplayLink对象，并将其添加到当前的run loop中。在每次屏幕刷新时，会调用update方法。在update方法中，我们记录每次调用的次数，并计算时间间隔。当时间间隔超过1秒时，我们计算FPS并进行相应的处理。最后，我们重置计数和时间戳，以便下一次计算。\n请注意，使用CADisplayLink计算的FPS只是一个指导意义，不能代表真实的FPS。因为CADisplayLink是以屏幕刷新频率为基准的，而在实际应用中，可能存在其他因素（例如CPU和GPU的性能）影响帧率。因此，这个FPS指示器只能作为一个参考，不能完全准确地反映屏幕的帧率。")]),e._v(" "),a("h1",{attrs:{id:"怎样监听-runloop-的-source0-事件和进入休眠前-然后设定一个阈值-监听卡顿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎样监听-runloop-的-source0-事件和进入休眠前-然后设定一个阈值-监听卡顿"}},[e._v("#")]),e._v(" 怎样监听 runloop 的 source0 事件和进入休眠前，然后设定一个阈值，监听卡顿")]),e._v(" "),a("p",[e._v("要监听 RunLoop 的 source0 事件和进入休眠前的方法，可以使用 CFRunLoopObserver 来实现。CFRunLoopObserver 是一个观察者，可以监听 RunLoop 的状态变化，并在特定的时间点执行相应的操作。\n以下是具体的步骤：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("创建一个 CFRunLoopObserver 对象，并指定观察的时间点和观察的事件类型。可以使用 CFRunLoopObserverCreate 函数来创建观察者对象。")])]),e._v(" "),a("li",[a("p",[e._v("定义一个回调函数，用于在观察的时间点执行相应的操作。回调函数的参数包括观察者对象、观察的事件类型和上下文信息。")])]),e._v(" "),a("li",[a("p",[e._v("将观察者对象添加到 RunLoop 的指定模式下。可以使用 CFRunLoopAddObserver 函数将观察者对象添加到 RunLoop 中。")])]),e._v(" "),a("li",[a("p",[e._v("在回调函数中，可以根据观察的事件类型执行相应的操作。例如，在监听进入休眠前的事件时，可以记录当前时间，并与上一次记录的时间进行比较，判断是否发生了卡顿。")])]),e._v(" "),a("li",[a("p",[e._v("根据需要，可以设置一个阈值来判断卡顿的时间。如果超过了阈值，可以进行相应的处理，例如打印日志、发送通知或采取其他措施。")])])]),e._v(" "),a("p",[e._v('以下是一个示例代码，演示如何监听 RunLoop 的 source0 事件和进入休眠前的方法，并设定一个阈值来监听卡顿：\nc复制代码// 定义观察者的回调函数\nvoid runLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {\nif (activity == kCFRunLoopBeforeSources) {\n// 在 source0 事件之前执行的操作\nNSLog(@"Before sources");\n} else if (activity == kCFRunLoopBeforeWaiting) {\n// 在进入休眠前执行的操作\nNSLog(@"Before waiting");')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('    // 记录当前时间\n    NSDate *currentDate = [NSDate date];\n    \n    // 获取上一次记录的时间\n    NSDate *lastDate = (__bridge NSDate *)(info);\n    \n    // 计算时间差\n    NSTimeInterval timeInterval = [currentDate timeIntervalSinceDate:lastDate];\n    \n    // 设置阈值，判断是否发生卡顿\n    NSTimeInterval threshold = 1.0; // 1秒\n    if (timeInterval > threshold) {\n        NSLog(@"Cardon detected");\n    }\n    \n    // 更新上一次记录的时间\n    CFDateRef dateRef = (__bridge_retained CFDateRef)(currentDate);\n    CFRelease((__bridge CFTypeRef)(lastDate));\n    *(CFDateRef *)(info) = dateRef;\n}\n')])])]),a("p",[e._v("}")]),e._v(" "),a("p",[e._v("// 创建观察者对象\nCFRunLoopObserverContext context = {0, (__bridge void *)([NSDate date]), NULL, NULL, NULL};\nCFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &runLoopObserverCallback, &context);")]),e._v(" "),a("p",[e._v("// 将观察者对象添加到 RunLoop 的默认模式下\nCFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopDefaultMode);")]),e._v(" "),a("p",[e._v("// 运行 RunLoop\nCFRunLoopRun();")]),e._v(" "),a("p",[e._v("// 释放观察者对象\nCFRelease(observer);")]),e._v(" "),a("p",[e._v("这样，就可以监听 RunLoop 的 source0 事件和进入休眠前的方法，并设定一个阈值来监听卡顿。")]),e._v(" "),a("h1",{attrs:{id:"如何做耗电优化-如何监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做耗电优化-如何监控"}},[e._v("#")]),e._v(" 如何做耗电优化，如何监控")]),e._v(" "),a("p",[e._v("iOS耗电优化方法可以通过以下几个步骤来实现：")]),e._v(" "),a("ul",[a("li",[e._v("使用Energy impact进行耗电检测：")])]),e._v(" "),a("ol",[a("li",[e._v("在Xcode中，通过选择Product->Profile或使用快捷键cmd+i，然后选择Energy impact来查看应用的耗电情况[1]。")]),e._v(" "),a("li",[e._v("查看Average Energy Impact来评估应用的总体平均耗电量，根据颜色区分耗电等级，如low、high和very high[1]。")]),e._v(" "),a("li",[e._v("查看Average Component Utilization来了解各个耗电部分的占比，包括Overhead、Network、CPU、GPU和Location[1]。")]),e._v(" "),a("li",[e._v("通过Profiler进一步分析耗电占比大的部分，如使用Time Profiler来查找最耗时的函数或方法[1]。")])]),e._v(" "),a("ul",[a("li",[e._v("使用Energy Log进行耗电检测：")])]),e._v(" "),a("ol",[a("li",[e._v("在设备上启用Energy Log功能，可以通过iPhone的设置->开发者->Logging->Start Recording来开始记录耗电数据[1]。")]),e._v(" "),a("li",[e._v("运行应用并进行各种操作，然后停止记录，将数据导入到Xcode的Instruments工具中进行分析[1]。")])]),e._v(" "),a("ul",[a("li",[e._v("使用sysdiagnose进行耗电检测：")])]),e._v(" "),a("ol",[a("li",[e._v("sysdiagnose是一种收集系统诊断信息的工具，可以用于分析电池使用情况[2]。")]),e._v(" "),a("li",[e._v("通过sysdiagnose可以获取电压、电流、温度等电池相关数据，以及应用的功耗信息[2]。")])]),e._v(" "),a("ul",[a("li",[e._v("优化耗电量：")])]),e._v(" "),a("ol",[a("li",[e._v("优化CPU使用：通过分析Time Profiler或sysdiagnose的数据，找出CPU占用高的函数或方法，并进行优化，如减少循环次数、使用异步操作等[1][2]。")]),e._v(" "),a("li",[e._v("优化网络使用：减少网络请求次数，合并请求，使用缓存等方式来降低网络耗电[1]。")]),e._v(" "),a("li",[e._v("优化定位使用：根据需求选择合适的定位精度，避免过高的精度导致的额外能耗[1]。")]),e._v(" "),a("li",[e._v("优化GPU使用：减少不必要的图形渲染操作，避免过度绘制等[1]。")])]),e._v(" "),a("h1",{attrs:{id:"如何做网络优化-如何监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做网络优化-如何监控"}},[e._v("#")]),e._v(" 如何做网络优化，如何监控")]),e._v(" "),a("p",[e._v("iOS网络优化方法可以从减少请求带宽和降低请求延迟两个方面进行优化。同时，监控网络性能也是很重要的，可以帮助我们了解应用的网络状况并及时发现问题。\n以下是一些iOS网络优化的方法和监控网络性能的工具：")]),e._v(" "),a("h2",{attrs:{id:"ios网络优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios网络优化方法"}},[e._v("#")]),e._v(" iOS网络优化方法：")]),e._v(" "),a("ul",[a("li",[e._v("减少请求带宽：")])]),e._v(" "),a("ol",[a("li",[e._v("使用高效的数据交互模式。")]),e._v(" "),a("li",[e._v("在可能的情况下使用预先压缩的数据。")]),e._v(" "),a("li",[e._v("压缩每一个请求与响应负载[1]。")])]),e._v(" "),a("ul",[a("li",[e._v("降低请求延迟：")])]),e._v(" "),a("ol",[a("li",[e._v("最小化DNS查询的数量，可以使用DNS预下载进行更早的DNS解析。")]),e._v(" "),a("li",[e._v("最大程度减少应用发起的连接数，请求结束时不要关闭HTTPS连接，使用域分片等方式来减少SSL握手时间。")]),e._v(" "),a("li",[e._v("在单个TCP连接上发送HTTP请求，以管道的形式发送HTTP请求，避免多个TCP连接的开销[1]。")])]),e._v(" "),a("h2",{attrs:{id:"ios网络性能监控工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios网络性能监控工具"}},[e._v("#")]),e._v(" iOS网络性能监控工具：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Network Link Conditioner：是iOS开发者工具中的一个功能，可以模拟不同网络环境下的网络连接状况，帮助开发者测试应用在不同网络条件下的性能表现。")])]),e._v(" "),a("li",[a("p",[e._v("Charles Proxy：是一款常用的网络抓包工具，可以用于监控和分析iOS设备上的网络请求和响应，帮助开发者了解应用的网络状况。")])]),e._v(" "),a("li",[a("p",[e._v("Firebase Performance Monitoring：是Google提供的一款移动应用性能监控工具，可以监控应用的网络请求、响应时间等性能指标，并提供实时的性能报告和分析。")])]),e._v(" "),a("li",[a("p",[e._v("Alamofire Network Logger：是一款基于Alamofire网络库的日志记录工具，可以记录和显示iOS应用的网络请求和响应的详细信息，方便开发者进行网络性能分析。")])])]),e._v(" "),a("p",[e._v("以上是一些常用的iOS网络优化方法和监控工具，通过优化网络性能和监控网络状况，可以提升应用的用户体验和性能表现。")])])}),[],!1,null,null,null);i.default=n.exports}}]);