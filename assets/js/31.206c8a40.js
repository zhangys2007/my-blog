(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{758:function(t,n,i){"use strict";i.r(n);var r=i(5),e=Object(r.a)({},(function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"nsurl-urlwithstring-urlstring-默认实现逻辑变动"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#nsurl-urlwithstring-urlstring-默认实现逻辑变动"}},[t._v("#")]),t._v(" [NSURL URLWithString:urlString]默认实现逻辑变动")]),t._v(" "),i("p",[t._v("[NSURL URLWithString:urlString]以前的逻辑是urlString有中文字符就返回nil，现在是默认对非法字符（包含中文）进行%转义。")]),t._v(" "),i("p",[t._v("URLWithString:方法并没有给出说明，但是iOS17新增了URLWithString:encodingInvalidCharacters:方法，具体可以参照此方法。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("/// Initializes and returns a newly created `NSURL` with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.\n/// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.\n/// If `encodingInvalidCharacters` is true, `NSURL` will try to encode the string to create a valid URL.\n/// If the URL string is still invalid after encoding, `nil` is returned.\n///\n/// - Parameter URLString: The URL string.\n/// - Parameter encodingInvalidCharacters: True if `NSURL` should try to encode an invalid URL string, false otherwise.\n/// - Returns: An `NSURL` instance for a valid URL, or `nil` if the URL is invalid.\n+ (nullable instancetype)URLWithString:(NSString *)URLString encodingInvalidCharacters:(BOOL)encodingInvalidCharacters API_AVAILABLE(macos(14.0), ios(17.0), watchos(10.0), tvos(17.0));\n")])])]),i("h1",{attrs:{id:"附带的bug"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#附带的bug"}},[t._v("#")]),t._v(" 附带的BUG")]),t._v(" "),i("p",[t._v("这一个改动本来没有什么大问题，但问题是有BUG。")]),t._v(" "),i("p",[t._v("如果urlString中没有中文，那urlString里原有的%字符不会转义。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('(lldb) po [NSURL URLWithString:@"http://a.com?redirectUri=http%3A%2F%2Fb.com"]\nhttp://a.com?redirectUri=http%3A%2F%2Fb.com\n')])])]),i("p",[t._v("如果urlString中有中文字符，那么中文字符和%字符都会被转义，最终会影响运行效果。")]),t._v(" "),i("p",[t._v("（我就是因为这个BUG，从而导致原本能正常进行302重定向的页面无法重定向。）")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('(lldb) po [NSURL URLWithString:@"http://a.com?title=标题&redirectUri=http%3A%2F%2Fb.com"]\nhttp://a.com?title=%E6%A0%87%E9%A2%98&redirectUri=http%253A%252F%252Fb.com\n')])])]),i("h1",{attrs:{id:"修改方案"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#修改方案"}},[t._v("#")]),t._v(" 修改方案")]),t._v(" "),i("p",[t._v("对原方法进行替换，保证[NSURL URLWithString:urlString]在iOS17系统上的运行逻辑和iOS17以下系统保持一致。这样对于现有代码逻辑的影响最小。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('#import "NSURL+iOS17.h"\n@implementation NSURL (iOS17)\n\n+(void)load {\n    Method ori_Method = class_getClassMethod(self, @selector(URLWithString:));\n    Method my_Method = class_getClassMethod(self, @selector(wt_URLWithString:));\n    method_exchangeImplementations(ori_Method, my_Method);\n}\n\n+ (instancetype)wt_URLWithString:(NSString *)URLString {\n    if (@available(iOS 17.0, *)) {\n        return [self URLWithString:URLString encodingInvalidCharacters:NO];\n    } else {\n        return [self wt_URLWithString:URLString];\n    }\n}\n\n@end\n')])])]),i("h1",{attrs:{id:"end"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#end"}},[t._v("#")]),t._v(" END")])])}),[],!1,null,null,null);n.default=e.exports}}]);