(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{751:function(n,e,t){"use strict";t.r(e);var i=t(5),v=Object(i.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"响应者链条"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应者链条"}},[n._v("#")]),n._v(" 响应者链条")]),n._v(" "),t("p",[n._v("关于响应者链条，相信大家可能听说过这么一句话："),t("strong",[n._v("事件由上往下传递，响应由下往上传递")]),n._v("，那么这句话是什么意思呢？\n我们知道，在写UI时，每个UI控件，或是UI视图，都是从最初的一个UIView上，不断调用addSubview方法，叠加在父view上，进行展示的。\n例如，假设我们有下面这么一段代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("UIView *view1, *view2;\nUIButton *btn1;\n\nview1 = [UIView new];\nview2 = [UIView new];\nbtn1 = [UIButton new];\n\n[view1 addSubview:view2];\n[view2 addSubview:btn1];\n")])])]),t("p",[n._v("显而易见，view2的父视图为view1，btn1的父视图为view2。\n如果我们现在在btn1上有一个点击事件，那么这个点击事件会直接传递给btn1吗？\n答案是否定的，因为事件是由上往下传递的，这个事件会先传递给view1，再传递给view2，最后传递给btn1。\n事件传递主要依靠下面这个函数来实现：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    // 3种状态无法响应事件，1.用户交互被禁用；2.当前视图被隐藏；3.当前视图透明度小于0.01（跟被隐藏了差不多）\n    if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil;\n    \n    // 触摸点若不在当前视图上则无法响应事件\n    if ([self pointInside:point withEvent:event] == NO) return nil;\n    // 从后往前遍历子视图数组\n    int count = (int)self.subviews.count; // 子视图数目\n    for (int i = count - 1; i >= 0; i--) {\n        // 获取子视图\n        UIView *childView = self.subviews[i];\n        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标\n        CGPoint childP = [self convertPoint:point toView:childView];\n        // 询问子视图层级中的最佳响应视图\n        UIView *fitView = [childView hitTest:childP withEvent:event];\n        if (fitView){\n            // 如果子视图中有更合适的就返回\n            return fitView;\n        }\n    }\n    // 没有在子视图中找到更合适的响应视图，那么自身就是最合适的\n    return self;\n}\n")])])]),t("p",[n._v("从函数中可以看出，事件传递的流程为：")]),n._v(" "),t("ol",[t("li",[n._v("如果当前视图无法响应事件，则返回nil")]),n._v(" "),t("li",[n._v("如果当前点击处在当前视图可响应范围之外，则返回nil")]),n._v(" "),t("li",[n._v("从后往前遍历子视图，如果子视图能够处理当前事件，则返回子视图")]),n._v(" "),t("li",[n._v("否则返回自身视图")])]),n._v(" "),t("p",[n._v("其中，第3步中，从后往前而不是从前往后遍历子视图的原因是：后加入的子视图会覆盖在先前加入的子视图之上，从用户角度来说，用户希望得到响应的视图应该是能够被看见的视图，而后加入的子视图因为会覆盖在最顶层所以更容易被用户看见，因此应该从后往前遍历。")]),n._v(" "),t("p",[n._v("此外，我们也应该注意pointInside: withEvent:这个方法，是很多面试官爱考的考点。 我们可以通过overwrite这个方法，来改变一个视图能够响应的范围（默认能够响应的范围是这个视图包含的屏幕区域）。")]),n._v(" "),t("p",[n._v("关于响应从下往上传递：我们在将事件从上往下传递后，利用- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event方法找到的最合适的响应视图，并不一定能够处理当前事件，仍按照上面的例子来说，假设我们有如下代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("UIView *view1, *view2;\nUIButton *btn1;\n\nview1 = [UIView new];\nview2 = [UIView new];\nview2.userInteractionEnabled = YES;\nbtn1 = [UIButton new];\n\n[view1 addSubview:btn1];\n[btn1 addSubview:view2];\n")])])]),t("p",[n._v("注意与之前的区别，现在view2的父视图为btn1，而btn1的父视图为view1，view2和btn1的父子关系互相调换了。 此外，我们还开启了view2的用户交互属性。")]),n._v(" "),t("p",[n._v("如果我们现在在btn1上有一个点击事件，按照事件从上往下传递的流程，我们会找到view2。 然而，我们会发现view2并不能够处理这个点击事件，因此，这个点击事件便由下往上传递给了btn1，并交由btn1处理（btn1能够处理，则调用相应的响应方法进行处理）。 假设btn1仍然不能处理，则继续往上传递给view1，直至事件被处理或者最后被丢弃。")]),n._v(" "),t("h2",{attrs:{id:"uibutton的继承关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uibutton的继承关系"}},[n._v("#")]),n._v(" UIButton的继承关系")]),n._v(" "),t("p",[n._v("UIButton的继承关系为：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("UIButton --\x3e UIControl --\x3e UIView --\x3e UIResponder --\x3e NSObject\n")])])]),t("p",[n._v("我们要注意UIResponder和UIControl的区别：")]),n._v(" "),t("ol",[t("li",[n._v("UIResponder可以响应某个事件，利用touchesBegan: withEvent:方法（自己的事情自己做）")]),n._v(" "),t("li",[n._v("UIControl不仅本身可以响应某个事件，还可以利用addTarget: forSelector: withEvent:为指定的某个对象添加事件（交给别人来做）")])]),n._v(" "),t("p",[n._v("例如，普通的UIView想要响应事件，只能依靠自身实现touchesBegan: withEvent:方法； 而UIButton想要响应事件，不仅可以依靠自身，还可以将这个事件绑定到一个目标对象上，依靠目标对象的某个方法来处理事件。")])])}),[],!1,null,null,null);e.default=v.exports}}]);