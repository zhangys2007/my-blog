(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{761:function(e,o,n){"use strict";n.r(o);var t=n(5),a=Object(t.a)({},(function(){var e=this,o=e.$createElement,n=e._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),n("p",[e._v("就 iOS 开发而言，关于 copy 的几个概念：")]),e._v(" "),n("ol",[n("li",[e._v("拷贝：即复制，目的是产生副本，让原对象和副本相互独立，互不影响；")]),e._v(" "),n("li",[e._v("不可变拷贝：即 copy 方法，无论原对象是否可变，都产生不可变副本；")]),e._v(" "),n("li",[e._v("可变拷贝：即 mutableCopy 方法，无论原对象是否可变，都产生可变副本；")]),e._v(" "),n("li",[e._v("深拷贝：内容拷贝，产生新的对象；")]),e._v(" "),n("li",[e._v("浅拷贝：指针拷贝，不产生新的对象；")])]),e._v(" "),n("p",[e._v("由上可知，copy 和深拷贝是两个概念，两者并不一定相等，先给结果：")]),e._v(" "),n("ul",[n("li",[e._v("源对象不可变时，copy 方法就是浅拷贝；")]),e._v(" "),n("li",[e._v("源对象可变时，copy 方法就是深拷贝；")]),e._v(" "),n("li",[e._v("mutableCopy 方法无论何种情况都是深拷贝；")])]),e._v(" "),n("h1",{attrs:{id:"copy-修饰属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copy-修饰属性"}},[e._v("#")]),e._v(" copy 修饰属性")]),e._v(" "),n("p",[e._v("上文中知道了，拷贝分深拷贝和浅拷贝，那么@property中的copy关键字是干嘛的呢？有没有 mutablecopy 关键字呢？\n先说结论：")]),e._v(" "),n("ul",[n("li",[e._v("属性中 copy 关键字的作用就是调用被赋值给属性的对象的copyWithZone方法，并将返回值赋值给属性;")])]),e._v(" "),n("p",[e._v("再来看源码, 首先看一段我们常用的属性声明代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("@interface XKPerson()\n@property (copy, nonatomic) NSString *name;\n@property (assign, nonatomic) NSInteger age;\n\n@end\n\n@implementation XKPerson\n\n@end\n")])])]),n("p",[e._v("使用编译指令生成 cpp 文件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc XKPerson.m -o XKPerson.cpp\n")])])]),n("p",[e._v("然后我们来找找property最后生成的代码是怎样的，cpp 文件中关于属性的实现代码如图所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('// @interface XKPerson()\n// @property (copy, nonatomic) NSString *name;\n// @property (assign, nonatomic) NSInteger age;\n/* @end */\n\n// @implementation XKPerson\n\nstatic NSString * _I_XKPerson_name(XKPerson * self, SEL _cmd) { return (*(NSString **)((char *)self + OBJC_IVAR_$_XKPerson$_name)); }\nextern "C" __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);\n\nstatic void _I_XKPerson_setName_(XKPerson * self, SEL _cmd, NSString *name) { objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct XKPerson, _name), (id)name, 0, 1); }\n\nstatic NSInteger _I_XKPerson_age(XKPerson * self, SEL _cmd) { return (*(NSInteger *)((char *)self + OBJC_IVAR_$_XKPerson$_age)); }\nstatic void _I_XKPerson_setAge_(XKPerson * self, SEL _cmd, NSInteger age) { (*(NSInteger *)((char *)self + OBJC_IVAR_$_XKPerson$_age)) = age; }\n// @end\n')])])]),n("p",[e._v("也就是说，@property只是告诉编译器，帮我生成 setter和 getter方法，也就是声明并实现了四个方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    static NSString * _I_XKPerson_name\n    static void I_XKPerson_setName\n    static NSInteger _I_XKPerson_age\n    static void I_XKPerson_setAge\n")])])]),n("p",[e._v("这里，因为我们在探究属性中的 copy，而且 copy 只在设置属性的时候起作用，所以我们只需要关注 "),n("em",[e._v("I_XKPerson_setName")]),e._v(" 这个方法即可，其核心是调用了objc_setProperty()这个函数，那么我们来到 objc4 的源码，下载 源码后看看objc_setProperty这个函数做了啥，代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    #define MUTABLE_COPY 2\n    void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n    {\n        bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);\n        bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n        // copy 和 mutableCopy最多只有一个为真(1)\n        reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n    }\n")])])]),n("p",[e._v("其余代码就不贴了，MUTABLE_COPY值为2，而setter中传的值为1，最终会进入到reallySetProperty这个方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy){\n    if (offset == 0) {\n        // 修改 isa 指向\n        object_setClass(self, newValue);\n        return;\n    }\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n    // copy的逻辑\n    if (copy) {\n        // 属性修饰关键字只有 copy\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        // 属性修饰关键字只有 copy , 这里是实现了 mutableCopying 协议时的处理逻辑\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n    // 释放原对象\n    objc_release(oldValue);\n    }\n")])])]),n("p",[e._v("其实这段代码还是挺经典的，但是我们只看 copy 的部分：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    // copy的逻辑\n    if (copy) {\n        // 属性修饰关键字只有 copy ，所以最终会进入到这里\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        // 属性修饰关键字只有 copy , 这里是实现了 mutableCopying 协议时的处理逻辑\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n\n        // NSString等不可变对象调用copy，其内部的代码逻辑会走到这里来\n        // 此时 copy 不产生新的对象，属于浅拷贝，所以 copy 和 retain 的代码逻辑等价(但是可不能将 copy 关键字替换成 retain 哦😯~)\n        newValue = objc_retain(newValue);\n    }\n")])])]),n("p",[e._v("从源码中就一目了然了：")]),e._v(" "),n("ol",[n("li",[e._v("如果是 copy 方法，则调用对象的 copyWithZone方法；")]),e._v(" "),n("li",[e._v("如果是mutablecopy，则调用对象的mutableCopyWithZone 方法；")]),e._v(" "),n("li",[e._v("如果 copy = 0，mutablecopy = 0，那么最终会调用objc_retain方法；")])]),e._v(" "),n("p",[e._v("其中，使用retain修饰属性时，就是第三种情况，代码中也可以得到验证，修改copy为 retain后编译的结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    // 最后一个参数由 1 变成了 0\n    static void _I_XKPerson_setName_(XKPerson * self, SEL _cmd, NSString *name) {   \n        objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct XKPerson, _name), (id)name, 0, 0); \n    }\n")])])]),n("p",[e._v("另外，如果使用 strong 和 assign修饰，最终 setter 不调用 objc_setProperty方法而是通过偏移量进行指针赋值或者直接赋值，具体就不再这里探讨了~~")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("这里留个疑问：")]),e._v(" "),n("p",[e._v("如果用 copy 修饰，那么属性最终转化成的 setter 中执行的 objc_setProperty 方法的传值中，最后一个参数永远为1。而objc_setProperty内部调用的也是reallySetProperty方法。为1时，调用reallySetProperty方法中的参数永远是bool copy = 1, bool mutablecopy = 0，也就是会走到copyWithZone这层逻辑。而使用 retain修饰属性，参数bool copy = 0, bool mutablecopy = 0，会走到obje_retain这层逻辑，归纳如下：")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("关键字")]),e._v(" "),n("th",[e._v("参数copy的值")]),e._v(" "),n("th",[e._v("参数mutablecopy的值")]),e._v(" "),n("th",[e._v("代码逻辑")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("retain")]),e._v(" "),n("td",[e._v("0")]),e._v(" "),n("td",[e._v("0")]),e._v(" "),n("td",[e._v("obje_retain()")])]),e._v(" "),n("tr",[n("td",[e._v("copy")]),e._v(" "),n("td",[e._v("1")]),e._v(" "),n("td",[e._v("0")]),e._v(" "),n("td",[e._v("copyWithZone()")])])])]),e._v(" "),n("p",[e._v("只有objc_setProperty最后一个参数为 2 时，才会走到 mutableCopy 的逻辑，所以reallySetProperty方法中的mutablecopyWithZone的代码何时会被调用呢？？？")]),e._v(" "),n("h1",{attrs:{id:"使用-copy-修饰字符串意义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-copy-修饰字符串意义"}},[e._v("#")]),e._v(" 使用 copy 修饰字符串意义")]),e._v(" "),n("p",[e._v("先说结论，使用 copy 修饰属性的意义在于：")]),e._v(" "),n("p",[e._v("明确告诉使用者，设计者不希望且不能直接修改属性对象所指向的内存地址的值；")]),e._v(" "),n("p",[e._v("不希望体现在使用使用 NSString 类型来声明属性，这样如果使用 appendString:的方法，就报报编译错误。\n但是，如果使用 strong 来修饰字符串属性，加上强制类型转换，仍然可以实现直接修改内存地址中的值：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    // person对象中使用 strong 修饰 属性\n    @property (strong, nonatomic) NSString *name1;\n    XKPerson *p = [XKPerson new];   \n    NSMutableString *name = [[NSMutableString alloc] initWithFormat:@"%@",@"Jack"];\n    // 此时如果是用 strong 修饰 name，虽然声明的是 NSString 对象，但实际类型是 NSMutableString 类型\n    p.name = name;\n    [(NSMutableString *)p.name appendFormat:@"1"];\n')])])]),n("p",[e._v("以上代码就实现了直接修改属性所指向的内存地址中的值，此时修改成使用 copy 修饰，因为调用的copyWithZone，结果返回的必定是不可变类型，所以即使赋值时是NSMutableString类型，最终得到的仍然是NSString类型，这样就起到了预期的效果；\n所以，NSString 类型使用 copy 修饰是最好不过的~~~")]),e._v(" "),n("p",[e._v("这里还涉及到一个场景，比如我们开发中，希望字符串属性跟随某个字符串对象的值同时改变，这个时候就要使用 strong + NSMutableString了：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    @property (strong, nonatomic) NSMutableString *name;\n    // 使用\n    XKPerson *p = [XKPerson new];\n    NSMutableString *name = [NSMutableString stringWithFormat:@"王"];\n    p.name = name;\n    NSLog(@"%@",p.name);\n    [name appendString:@"小二"];\n    NSLog(@"%@",p.name);\n')])])]),n("p",[e._v("结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    2019-12-27 17:53:51.730 XKStringTest[10172:63201310] 王\n    2019-12-27 17:53:51.731 XKStringTest[10172:63201310] 王小二\n")])])]),n("p",[e._v('这个时候如果使用 copy 修饰，再使用[self.name appendString：@"xxx"] 反而会崩溃，和使用 copy 修饰 NSMutableArray 时同理。\n再重申一遍：copy 是为了获得不可变副本，mutableCopy 是为了获取可变副本，而修饰属性的关键字只有 copy。\n这个场景中使用其实应该使用 mutableCopy 修饰，创建的就是可变的独立字符串副本了，但是 没有 mutableCopy 关键字修饰属性。\n所以，切记哦😯：')]),e._v(" "),n("p",[e._v("在属性中不要使用 copy 修饰NSMutableArray、NSMutableDictionary等可变类型；")]),e._v(" "),n("h1",{attrs:{id:"copy-协议"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copy-协议"}},[e._v("#")]),e._v(" copy 协议")]),e._v(" "),n("p",[e._v("上一章节讲到了属性修饰中 copy 关键字的本质是调用copyWithZone方法。之所以能够使用 copy 修饰字符串、数组等，是因为这些系统对象实现了 copy 相关的协议。\n所以，这里就涉及到一个问题：自定义copyWithZone方法。平常我们使用 copy 修饰的最多的就是字符串\n因此，OC 中给我们提供了两个协议：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    @protocol NSCopying\n    - (id)copyWithZone:(nullable NSZone *)zone;\n    @end\n\n    @protocol NSMutableCopying\n    - (id)mutableCopyWithZone:(nullable NSZone *)zone;\n    @end\n")])])]),n("p",[e._v("具体实现如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    - (id)copyWithZone:(NSZone *)zone {\n        XKPerson *newP = [[XKPerson allocWithZone:zone] init];\n        newP.name = self.name;\n        newP.age = self.age;\n        return newP;\n    }\n\n    - (id)mutableCopyWithZone:(NSZone *)zone {\n        XKPerson *newP = [[XKPerson allocWithZone:zone] init];\n        newP.name = self.name;\n        newP.age = 10;\n        return newP;\n    }\n")])])]),n("p",[e._v("使用：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    XKPerson *p = [XKPerson new];\n    p.name = @"Jack";\n    p.age = 18;\n    XKPerson *p1 = [p copy];\n    XKPerson *p2 = [p mutableCopy];\n    NSLog(@"%p %p %p", p, p1, p2);\n    p1.name = @"Lucy";\n    NSLog(@"%@",p1.name);\n')])])]),n("p",[e._v("结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    2019-12-27 17:42:11.326 XKStringTest[9991:63192515] 0x7ae30b10 0x7ae31340 0x7ae313e0\n    2019-12-27 17:42:11.327 XKStringTest[9991:63192515] Lucy\n")])])]),n("p",[e._v("copy 在数据模型 model 中时可能会较多使用 copy，此时实现copy协议即可，但在平时自定义对象使用 copy 并不多，这两个协议就不多说了~~")]),e._v(" "),n("h1",{attrs:{id:"block-为什么使用-copy-修饰"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#block-为什么使用-copy-修饰"}},[e._v("#")]),e._v(" Block 为什么使用 copy 修饰")]),e._v(" "),n("p",[e._v("会在 block进阶中讲到，但是这里也把核心说一下，来看一段代码就能看到本质，非 ARC 模式下代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    int main(int argc, const char * argv[]) {\n        @autoreleasepool {\n        // 看看 block 中 copy 方法的本质\n        int age = 10;\n        void(^block)(void) = ^(void){\n            NSLog(@"%d",age);\n         };\n    \n        NSLog(@"%p",block);\n        NSLog(@"%@",[block class]);\n        block = [block copy];\n        NSLog(@"%p",block);\n        NSLog(@"%@",[block class]);\n\n        }\n        return 0;\n    }\n')])])]),n("p",[e._v("打印结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    2020-01-03 09:02:36.888792+0800 XKBlockTest[84409:72373799] 0x7ffeefbff488\n    2020-01-03 09:02:36.889375+0800 XKBlockTest[84409:72373799] __NSStackBlock__\n    2020-01-03 09:02:36.889904+0800 XKBlockTest[84409:72373799] 0x1006444b0\n    2020-01-03 09:02:36.889961+0800 XKBlockTest[84409:72373799] __NSMallocBlock__\n")])])]),n("p",[e._v("分析：")]),e._v(" "),n("ol",[n("li",[e._v("代码中只是为了测试，所以省去了 release 等操作；")]),e._v(" "),n("li",[e._v("copy 的本质和字符串等的实现大同小异，都是返回一个不可变对象；")]),e._v(" "),n("li",[e._v("因为访问了 auto 变量的 Block 作为__NSStackBlock__存放在栈中，否则作为__NSGlobalBlock__存放在数据区(全局区)，栈中的 Block 随时会被销毁，所以系统实现的 copy 操作在堆中创建了一个全新的 Block 并返回，这就是两次打印内存结果不一样的原因；")]),e._v(" "),n("li",[e._v("Block 存放在堆中时被标记成__NSMallocBlock__类型，非 ARC 中需要手动 release；")]),e._v(" "),n("li",[e._v("Block 使用 copy 修饰时，同字符串等一样，会调用新值的 copy 方法，也就是 Block 的 copy 方法；")]),e._v(" "),n("li",[e._v("Block 属性使用weak修饰不用多说，既不调用 copy 方法，也不增加引用计数器；")])]),e._v(" "),n("p",[e._v("直接说总结吧：\n因为 ARC 会在几种特定情况下主动调用 Block 的 copy 方法，比如被 strong 修饰时，GCD中的Block、系统的 UsingBlock 方法等，所以：")]),e._v(" "),n("ul",[n("li",[e._v("ARC 中的 Block 属性使用 copy 和 strong 修饰 Block 都可以")])]),e._v(" "),n("ol",[n("li",[e._v("使用 copy 修饰时，相当于主动调用 copy 方法，StackBlock 会被拷贝到堆上而成为 MallocBlock；")]),e._v(" "),n("li",[e._v("使用 strong 修饰时，ARC 模式下，会自动调用 copy 方法，StackBlock 会被拷贝到堆上而成为 MallocBlock；")])]),e._v(" "),n("ul",[n("li",[e._v("MRC 中的 Block 属性必须使用 copy 修饰")])]),e._v(" "),n("ol",[n("li",[e._v("使用 copy 修饰时，相当于主动调用 copy 方法，StackBlock 会被拷贝到堆上而成为 MallocBlock；")]),e._v(" "),n("li",[e._v("MRC 模式下，strong 修饰 Block 只会 retain，不会自动调用 Block 的 copy 方法；")])]),e._v(" "),n("h1",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("以上，总结下 copy 的几个重点，方便记忆：")]),e._v(" "),n("ol",[n("li",[e._v("copy 的目的是创建一个互不干扰，相互独立的副本；")]),e._v(" "),n("li",[e._v("copy 无论是直接调用还是修饰属性，其本质是调用copyWithZone和mutableCopyWithZone方法；")]),e._v(" "),n("li",[e._v("深浅复制的区别在于返回值是否为新创建的对象，和调用 copy 的哪个方法无关；")]),e._v(" "),n("li",[e._v("使用 copy 修饰属性的关键目的是告诉使用者，这个不要直接修改属性所指向内存中的值；")]),e._v(" "),n("li",[e._v("修饰可变类型的对象，比如可变数组，严禁使用 copy 修饰；")]),e._v(" "),n("li",[e._v("copy 的本质是调用 copy 协议中的两个方法，只是系统对字符串、数组、字典、NSNumber 和 Block 实现了该协议的两个方法，其中两个方法所实现的逻辑大同小异；")]),e._v(" "),n("li",[e._v("copy 修饰属性的本质是自动调用新值的 copy 方法以获取一个不可变对象，属性无 mutableCopy 修饰，因为没有必要；")]),e._v(" "),n("li",[e._v("copy 修饰 Block 属性的本质仍然是调用 copy 方法，只是其内部实现是将存放在栈上的 block 转移到堆上，否则栈中的 Block 被销毁后会访问指向该 Block 的指针会产生坏内存访问问题；")])])])}),[],!1,null,null,null);o.default=a.exports}}]);