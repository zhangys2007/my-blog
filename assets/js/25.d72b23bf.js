(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{748:function(e,t,n){"use strict";n.r(t);var a=n(5),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[n("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20201101/20201101.html"}},[e._v("单例模式")])],1),e._v(" "),n("h2",{attrs:{id:"_1-什么是代理模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是代理模式"}},[e._v("#")]),e._v(" 1. 什么是代理模式")]),e._v(" "),n("p",[e._v("比如我们一般登陆一些会员制的网站，通常一些功能只有会员才能访问，普通用户只能访问一些基础的内容，付费内容则需要充值会员才能访问。那么和代理模式有啥关系，代理的一个常见用处是作为一个轻量的替身对象，它运去客户端首先访问一些廉价的信息或功能，知道充值会员才提供付费的资源。因此代理在一开始向用户提供试用会员资格，当用户愿意为真正的高价的会员资格付费的时候，代理会敞开大门让用户访问付费会员的功能。\n信用卡是银行账户的代理， 银行账户则是一大捆现金的代理。 它们都实现了同样的接口， 均可用于进行支付。 消费者会非常满意， 因为不必随身携带大量现金； 商店老板同样会十分高兴， 因为交易收入能以电子化的方式进入商店的银行账户中， 无需担心存款时出现现金丢失或被抢劫的情况。\n通常带路模式有以下一些代理")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("远程代理：为位于不同地址空间或网络上的对象提供本地代表。")])]),e._v(" "),n("li",[n("p",[e._v("虚拟代理：更具需要创建重型对象。")])]),e._v(" "),n("li",[n("p",[e._v("保护代理： 更具各种访问权限控制原对象的访问")])]),e._v(" "),n("li",[n("p",[e._v("智能引用代理： 通过对真正对象的引用进行计数来管理内存。也用于锁定真正对象，让其他对象不能对其进行修改。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  代理模式：为其他对象提供一种代理以控制对这个对象的访问。\n")])])])])]),e._v(" "),n("h2",{attrs:{id:"_2-什么时候使用代理模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么时候使用代理模式"}},[e._v("#")]),e._v(" 2. 什么时候使用代理模式")]),e._v(" "),n("p",[e._v("下面的情形可以考虑使用代理模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    需要一个远程代理，为位于不同地址空间或网络中的对象提供本地代表\n    需要一个虚拟代理，来根据要求创建重型的对象。\n    需要一个保护代理，来根据不同访问权限控制对原对象的访问。\n    需要一个智能引用代理，通过对实体对象的引用进行计算来管理内存。\n")])])]),n("h2",{attrs:{id:"_3-代码展示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-代码展示"}},[e._v("#")]),e._v(" 3. 代码展示")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('    import XCTest\n\n    /// The Subject interface declares common operations for both RealSubject and\n    /// the Proxy. As long as the client works with RealSubject using this\n    /// interface, you\'ll be able to pass it a proxy instead of a real subject.\n    protocol Subject {\n        func request()\n    }\n\n    /// The RealSubject contains some core business logic. Usually, RealSubjects are\n    /// capable of doing some useful work which may also be very slow or sensitive -\n    /// e.g. correcting input data. A Proxy can solve these issues without any\n    /// changes to the RealSubject\'s code.\n    class RealSubject: Subject {\n\n        func request() {\n            print("RealSubject: Handling request.")\n        }\n    }\n\n    /// The Proxy has an interface identical to the RealSubject.\n    class Proxy: Subject {\n\n        private var realSubject: RealSubject\n\n        /// The Proxy maintains a reference to an object of the RealSubject class.\n        /// It can be either lazy-loaded or passed to the Proxy by the client.\n        init(_ realSubject: RealSubject) {\n            self.realSubject = realSubject\n        }\n\n        /// The most common applications of the Proxy pattern are lazy loading,\n        /// caching, controlling the access, logging, etc. A Proxy can perform one\n        /// of these things and then, depending on the result, pass the execution to\n        /// the same method in a linked RealSubject object.\n        func request() {\n\n            if (checkAccess()) {\n                realSubject.request()\n                logAccess()\n            }\n        }\n\n        private func checkAccess() -> Bool {\n\n            /// Some real checks should go here.\n\n            print("Proxy: Checking access prior to firing a real request.")\n\n            return true\n        }\n\n        private func logAccess() {\n            print("Proxy: Logging the time of request.")\n        }\n    }\n\n    /// The client code is supposed to work with all objects (both subjects and\n    /// proxies) via the Subject interface in order to support both real subjects\n    /// and proxies. In real life, however, clients mostly work with their real\n    /// subjects directly. In this case, to implement the pattern more easily, you\n    /// can extend your proxy from the real subject\'s class.\n    class Client {\n        // ...\n        static func clientCode(subject: Subject) {\n            // ...\n            print(subject.request())\n            // ...\n        }\n    // ...\n    }\n\n    /// Let\'s see how it all works together.\n    class ProxyConceptual: XCTestCase {\n\n        func test() {\n            print("Client: Executing the client code with a real subject:")\n            let realSubject = RealSubject()\n            Client.clientCode(subject: realSubject)\n\n            print("\\nClient: Executing the same client code with a proxy:")\n            let proxy = Proxy(realSubject)\n            Client.clientCode(subject: proxy)\n        }\n    }\n')])])]),n("h2",{attrs:{id:"_4-小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-小结"}},[e._v("#")]),e._v(" 4. 小结")]),e._v(" "),n("p",[e._v("在iOS中我们有一个NSProxy类，NSProxy类实现了NSObject协议，所以NSProxy对象实际上也是NSObject类型。NSProxy类是一个抽象基类。代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。")])])}),[],!1,null,null,null);t.default=s.exports}}]);