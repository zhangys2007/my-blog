(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{750:function(e,s,l){"use strict";l.r(s);var a=l(5),n=Object(a.a)({},(function(){var e=this,s=e.$createElement,l=e._self._c||s;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"前言"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),l("p",[e._v("在 OC 时代我们经常用到 weak self，主要为了解决循环引用，但在 swift 中，还有另外一个类似功能的关键字 unowned self。")]),e._v(" "),l("p",[e._v("weak self 大家已经用得很熟练了，但是 unowned self 肯定还有人没用过，今天就来讲讲这个两个的区别。")]),e._v(" "),l("h2",{attrs:{id:"weak-self"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#weak-self"}},[e._v("#")]),e._v(" weak self")]),e._v(" "),l("p",[e._v("weak self 表示对 self 的弱引用，即不保持对 self 的强引用。在闭包中访问 self 是一个可选类型，你需要在使用它时进行解包，如果在闭包调用之前被释放了，那么弱引用就会自动变为 nil。\n举个例子：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[e._v("class MyClass {\n    var closure: (() -> Void)?\n    func setupClosure() {\n        closure = { [weak self] in\n            guard let strongSelf = self else { return }\n            print(strongSelf)\n        }\n    }\n}\n")])])]),l("p",[e._v("MyClass 强引用 closure，closure 中又强引用 self，因此，如果在 closure 的闭包中不使用 weak self，将产生循环引用，导致 MyClass 无法释放。")]),e._v(" "),l("h2",{attrs:{id:"unowned-self"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#unowned-self"}},[e._v("#")]),e._v(" unowned self")]),e._v(" "),l("p",[e._v("unowned self 表示对 self 的无主引用，和 weak self 一样，也会对 self 进行弱引用，但它是一个不安全的弱引用，也就是说，闭包调用的时候如果 self 已经释放了，程序将会崩溃。和 weak self 还有一点不同的是，闭包中的 self 并不是可选类型，因此在使用时不需要解包。\n还是上边的例子，如果用 unowned self 实现：")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[e._v("class MyClass {\n    var closure: (() -> Void)?\n    func setupClosure() {\n        closure = { [unowned self] in\n            print(self)\n        }\n    }\n}\n")])])]),l("h2",{attrs:{id:"总结一下"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#总结一下"}},[e._v("#")]),e._v(" 总结一下")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("1.weak self 和 unowned self 都能对 self 进行弱引用，都能解决循环引用的问题。")])]),e._v(" "),l("li",[l("p",[e._v("2.weak self 的作用下，即使 self 已经释放了，在闭包中访问也是安全的 (只要不强制解包 self)。")])]),e._v(" "),l("li",[l("p",[e._v("3.unowned self的作用下，如果 self 已经释放了，在闭包中访问 self 会导致 crash，因此当你明确知道闭包中的 self 在闭包生命周期内始终存在时，才可以使用 unowned self，比如两个实例之间的关系是父子关系，并且子实例的生命周期不会超过父实例的情况下。")])]),e._v(" "),l("li",[l("p",[e._v("4.使用 unowned self 的好处是不需要在闭包中对 self 进行解包操作。")])])]),e._v(" "),l("h2",{attrs:{id:"end"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#end"}},[e._v("#")]),e._v(" END")])])}),[],!1,null,null,null);s.default=n.exports}}]);