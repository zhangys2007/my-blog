(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{708:function(n,r,a){n.exports=a.p+"assets/img/20200201.35b053ff.jpg"},740:function(n,r,a){"use strict";a.r(r);var t=a(5),e=Object(t.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[t("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20200101/20200101.html"}},[n._v("简单工厂")])],1),n._v(" "),t("h2",{attrs:{id:"什么是工厂方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是工厂方法"}},[n._v("#")]),n._v(" 什么是工厂方法？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类\n")])])]),t("h2",{attrs:{id:"结构图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构图"}},[n._v("#")]),n._v(" 结构图")]),n._v(" "),t("img",{attrs:{src:a(708),width:"80%"}}),n._v(" "),t("h2",{attrs:{id:"实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[n._v("#")]),n._v(" 实例")]),n._v(" "),t("p",[n._v("实现一个计算器，拥有加减乘除功能:\n1.抽象一个protocol(Operation), 即：对应结构图中的Product接口。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("protocol Operation {\n\n    var numberA: Double { set get }\n\n    var numberB: Double { set get }\n\n    func calculate() -> Double\n\n}\n")])])]),t("p",[n._v("2.抽象一个protocol(OperationFactory)，即：对应结构图中的Creator。协议里面有一个创建Operation类型的对象。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("protocol OperationFactory {\n\n    func creatOperation() -> Operation\n\n}\n")])])]),t("p",[n._v("3.定义具体的加减乘除的具体Operation对象，都需要实现Operation协议。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("struct OperationAdd: Operation {\n\n    var numberA: Double = 0.0\n\n    var numberB: Double = 0.0\n\n    func calculate() -> Double {\n        return numberA + numberB\n    }\n\n}\n\nstruct OperationSub: Operation {\n\n    var numberA: Double = 0.0\n\n    var numberB: Double = 0.0\n\n    func calculate() -> Double {\n        return numberA - numberB\n    }\n}\n\nstruct OperationMul: Operation {\n\n    var numberA: Double = 0.0\n\n    var numberB: Double = 0.0\n\n    func calculate() -> Double {\n        return numberA * numberB\n    }\n\n}\n\nstruct OperationDiv: Operation {\n\n    var numberA: Double = 0.0\n\n    var numberB: Double = 0.0\n\n    func calculate() -> Double {\n        if numberB != 0 {\n            return numberA / numberB\n        }\n        return 0\n    }\n}\n")])])]),t("p",[n._v("4.定义具体工厂类。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("class OperationAddFactory: OperationFactory {\n\n    func creatOperation() -> Operation {\n        return OperationAdd()\n    }\n}\n\nclass OperationSubFactory: OperationFactory {\n    func creatOperation() -> Operation {\n        return OperationSub()\n    }\n}\n\nclass OperationMulFactory: OperationFactory {\n    func creatOperation() -> Operation {\n        return OperationMul()\n    }\n}\n\nclass OperationDivFactory: OperationFactory {\n    func creatOperation() -> Operation {\n        return OperationDiv()\n    }\n}\n\n/// 客户端调用\nlet addFactory = OperationAddFactory()\nvar addOperation = addFactory.creatOperation()\naddOperation.numberA = 1\naddOperation.numberB = 2\naddOperation.calculate()\n\nlet subFactory = OperationSubFactory()\nvar subOperation = subFactory.creatOperation()\nsubOperation.numberA = 1\nsubOperation.numberB = 2\nsubOperation.calculate()\n\nlet mulFactory = OperationMulFactory()\nvar mulOperation = mulFactory.creatOperation()\nmulOperation.numberA = 1\nmulOperation.numberB = 2\nmulOperation.calculate()\n\nlet divFactory = OperationDivFactory()\nvar divOperation = divFactory.creatOperation()\ndivOperation.numberA = 1\ndivOperation.numberB = 2\ndivOperation.calculate()\n")])])]),t("h2",{attrs:{id:"工厂模式总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式总结"}},[n._v("#")]),n._v(" 工厂模式总结")]),n._v(" "),t("ul",[t("li",[n._v("工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现具体的运算类，与简单工厂相比较，其实选择判断问题还是存在，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码进行。")]),n._v(" "),t("li",[n._v("符合开闭原则。假如现在有需求需要增加一个开根号的运算，那么只需要增加一个该运算的具体工厂类和运算类。")]),n._v(" "),t("li",[n._v("工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。")])])])}),[],!1,null,null,null);r.default=e.exports}}]);