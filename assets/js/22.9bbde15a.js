(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{729:function(e,n,r){e.exports=r.p+"assets/img/20240108.165c89ab.jpg"},757:function(e,n,r){"use strict";r.r(n);var t=r(5),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"引子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引子"}},[e._v("#")]),e._v(" 引子")]),e._v(" "),t("p",[e._v("NSTimer 是 iOS Foundation 框架中一种计时器，在经过一定的时间间隔后触发，向目标对象发送指定的消息。")]),e._v(" "),t("p",[e._v("本文以标题为主线，探究 NSTimer 与 Runloop 之间的关系。")]),e._v(" "),t("p",[e._v("我们先看下面这段代码的运行：")]),e._v(" "),t("img",{attrs:{src:r(729),width:"100%"}}),e._v(" "),t("p",[e._v("场景：")]),e._v(" "),t("p",[e._v("ViewController --Present-> SecondViewController。其中 Manager 实例会持有 Block。\nSecondViewController 中有两个点击按钮，test1 按钮和 test2 按钮\n分别调度方法 -didTapTest1: 与 -didTapTest2:")]),e._v(" "),t("p",[e._v("流程：")]),e._v(" "),t("ol",[t("li",[e._v("点击 xx 按钮；")]),e._v(" "),t("li",[e._v("等待数秒，打印 block 中的内容；")]),e._v(" "),t("li",[e._v("关闭 SecondViewController 控制器；")])]),e._v(" "),t("p",[e._v("点击 test1 按钮执行流程，打印：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("2023-01-25 16:59:08.712191+0800 BlockMemoryLeaks[27573:1465591] Manager: <Manager: 0x6000002e40c0>\n")])])]),t("p",[e._v("点击 test2 按钮执行流程，打印：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("2023-01-25 17:01:47.305332+0800 BlockMemoryLeaks[27622:1467958] Timer: <__NSCFTimer: 0x6000000400c0>\n2023-01-25 17:01:48.305246+0800 BlockMemoryLeaks[27622:1467958] Timer: <__NSCFTimer: 0x6000000400c0>\n2023-01-25 17:01:49.141697+0800 BlockMemoryLeaks[27622:1467958] SecondViewController dealloc\n")])])]),t("p",[e._v("test1 Manager 和预期一样，Manager -> Block，Block -> self，self -> Manager，造成了循环引用。")]),e._v(" "),t("p",[e._v("而 test2 NSTimer 虽然被 self 持有，这个 Block 也捕获了 self，但这并没有触发循环引用。")]),e._v(" "),t("h2",{attrs:{id:"nstimer-与-runloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nstimer-与-runloop"}},[e._v("#")]),e._v(" NSTimer 与 Runloop")]),e._v(" "),t("p",[e._v("在苹果关于 NSTimer 文档中有描述，NSTimer 和 CFRunLoopTimerRef 是 toll-free bridged 的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("NSTimer is toll-free bridged with its Core Foundation counterpart, CFRunLoopTimerRef.\n")])])]),t("p",[e._v("NSTimer 是中间桥接层，意味着其实定时器运作是交给 Runloop 处理的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;\n")])])]),t("p",[e._v("即便是 NSTimer 是中间层，如果底层 Timer 持有了 Block，还是存在循环引用。接着阅读 Runloop 代码来找到标题问题的答案。")]),e._v(" "),t("h3",{attrs:{id:"runloop-的-mode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop-的-mode"}},[e._v("#")]),e._v(" RunLoop 的 Mode")]),e._v(" "),t("p",[e._v("CFRunloop 与 CFRunloop Mode 的大致结构如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("struct __CFRunLoopMode {\n    CFStringRef _name;            \n    CFMutableSetRef _sources0;    \n    CFMutableSetRef _sources1;    \n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;    \n    // ...\n};\n\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    CFMutableSetRef _commonModes;   \n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;  \n    CFMutableSetRef _modes;         \n    // ...\n};\n")])])]),t("p",[e._v("一个 CFRunLoop 中包含若干个 CFRunLoopMode，CFRunLoopTimer 则被注册在 mode 下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("struct __CFRunLoopTimer {\n    CFRuntimeBase _base;\n    uint16_t _bits;\n    pthread_mutex_t _lock;\n    CFRunLoopRef _runLoop;\n    CFMutableSetRef _rlModes;\n    CFAbsoluteTime _nextFireDate;\n    CFTimeInterval _interval;\t\t/* immutable */\n    CFTimeInterval _tolerance;          /* mutable */\n    uint64_t _fireTSR;\t\t\t/* TSR units */\n    CFIndex _order;\t\t\t/* immutable */\n    CFRunLoopTimerCallBack _callout;\t/* immutable */\n    CFRunLoopTimerContext _context;\t/* immutable, except invalidation */\n};\n")])])]),t("p",[e._v("CFRunLoopTimer 包含一个时间长度和一个回调，标记了它所在的 runloop mode。")]),e._v(" "),t("h3",{attrs:{id:"从添加-timer-开始"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从添加-timer-开始"}},[e._v("#")]),e._v(" 从添加 Timer 开始")]),e._v(" "),t("p",[e._v("先看 CFRunLoopAddTimer 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {    \n    CHECK_FOR_FORK();\n    if (__CFRunLoopIsDeallocating(rl)) return;\n    if (!__CFIsValid(rlt) || (NULL != rlt->_runLoop && rlt->_runLoop != rl)) return;\n    __CFRunLoopLock(rl);\n    if (modeName == kCFRunLoopCommonModes) {\n        /* Mode 是 CommonModes */\n        CFSetRef set = rl->_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl->_commonModes) : NULL;\n        if (NULL == rl->_commonModeItems) {\n            rl->_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);\n        }\n        CFSetAddValue(rl->_commonModeItems, rlt);\n        if (NULL != set) {\n            CFTypeRef context[2] = {rl, rlt};\n            /* 将 Timer 加入到所有 Common Mode 中 */\n            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);\n            CFRelease(set);\n        }\n    } else {\n        /* Mode 是指定 Mode */\n        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);\n        if (NULL != rlm) {\n            if (NULL == rlm->_timers) {\n                CFArrayCallBacks cb = kCFTypeArrayCallBacks;\n                cb.equal = NULL;\n                rlm->_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &cb);\n            }\n        }\n        if (NULL != rlm && !CFSetContainsValue(rlt->_rlModes, rlm->_name)) {\n            __CFRunLoopTimerLock(rlt);\n            if (NULL == rlt->_runLoop) {\n                // 标记 Timer 对应的 Runloop\n                rlt->_runLoop = rl;\n            } else if (rl != rlt->_runLoop) {\n                __CFRunLoopTimerUnlock(rlt);\n                __CFRunLoopModeUnlock(rlm);\n                __CFRunLoopUnlock(rl);\n                return;\n            }\n            // 标记 Timer 对应的 Runloop Mode\n            CFSetAddValue(rlt->_rlModes, rlm->_name);\n            __CFRunLoopTimerUnlock(rlt);\n            __CFRunLoopTimerFireTSRLock();\n            /* 重新排序指定 Mode 中的各个 Timer */\n            __CFRepositionTimerInMode(rlm, rlt, false);\n            __CFRunLoopTimerFireTSRUnlock();\n            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) {\n                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);\n            }\n        }\n        if (NULL != rlm) {\n            __CFRunLoopModeUnlock(rlm);\n        }\n    }\n    __CFRunLoopUnlock(rl);\n}\n")])])]),t("p",[e._v("CFRunLoopAddTimer("),t("em",[e._v(":")]),e._v(":"),t("em",[e._v("😃 将 Timer 添加到 Runloop 的指定 Mode 下。如果被添加的是 commonModes 则遍历所有 commonMode 调用 CFRunLoopAddTimer(")]),e._v(":"),t("em",[e._v(":")]),e._v("😃 方法。然后调用 __CFRepositionTimerInMode 函数排序：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) {\n    if (!rlt) return;\n    // 拿到 Mode 下所有 timer\n    CFMutableArrayRef timerArray = rlm->_timers;\n    if (!timerArray) return;\n    Boolean found = false;\n    if (isInArray) {\n        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt);\n        if (kCFNotFound != idx) {\n            CFRetain(rlt);\n            CFArrayRemoveValueAtIndex(timerArray, idx);\n            found = true;\n        }\n    }\n    if (!found && isInArray) return;\n    // 二分法确定位置，插入有序数组\n    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);\n    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);\n    // \n    __CFArmNextTimerInMode(rlm, rlt->_runLoop);\n    if (isInArray) CFRelease(rlt);\n}\n")])])]),t("p",[e._v("__CFRepositionTimerInMode 方法以触发时间 _fireTSR 从小到大排序 rlm->timers Mode 的 timers 数组。\n排序完成后调用 __CFArmNextTimerInMode 重新注册最早应该被触发的 timer")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) {    \n    uint64_t nextHardDeadline = UINT64_MAX;\n    uint64_t nextSoftDeadline = UINT64_MAX;\n    if (rlm->_timers) {\n        // 修正 tolerance 值，确保时间最近的 timer + tolerance 大于其他 Timer 时，不影响其他 Timer 触发\n        for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm->_timers); idx < cnt; idx++) {\n            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm->_timers , idx);\n            if (__CFRunLoopTimerIsFiring(t)) continue;\n            int32_t err = CHECKINT_NO_ERROR;\n            uint64_t oneTimerSoftDeadline = t->_fireTSR;\n            uint64_t oneTimerHardDeadline = check_uint64_add(t->_fireTSR, __CFTimeIntervalToTSR(t->_tolerance), &err);\n            if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;    \n\n            if (oneTimerSoftDeadline > nextHardDeadline) {\n                break;\n            }\n            if (oneTimerSoftDeadline < nextSoftDeadline) {\n                nextSoftDeadline = oneTimerSoftDeadline;\n            }\n            if (oneTimerHardDeadline < nextHardDeadline) {\n                nextHardDeadline = oneTimerHardDeadline;\n            }\n        }\n        if (nextSoftDeadline < UINT64_MAX && (nextHardDeadline != rlm->_timerHardDeadline || nextSoftDeadline != rlm->_timerSoftDeadline)) {\n            if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) {\n                CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time()));\n            }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n            uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline);\n            dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline);\n#if USE_MK_TIMER_TOO\n            if (leeway > 0) {\n                // 有 tolerance 采用 _dispatch_source_set_runloop_timer_4CF 方式注册定时器\n                if (rlm->_mkTimerArmed && rlm->_timerPort) {\n                    AbsoluteTime dummy;\n                    mk_timer_cancel(rlm->_timerPort, &dummy);\n                    rlm->_mkTimerArmed = false;\n                }\n                _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);\n                rlm->_dispatchTimerArmed = true;\n            } else {\n                // 没有 tolerance 采用 RunloopMode 的 mk_timer 方式注册 mach-port 事件\n                if (rlm->_dispatchTimerArmed) {\n                    _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888);\n                    rlm->_dispatchTimerArmed = false;\n                }\n                if (rlm->_timerPort) {\n                    mk_timer_arm(rlm->_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));\n                    rlm->_mkTimerArmed = true;\n                }\n            }\n#else\n            _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);\n#endif\n#else\n            if (rlm->_timerPort) {\n                mk_timer_arm(rlm->_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline));\n            }\n#endif\n        } else if (nextSoftDeadline == UINT64_MAX) {\n            // 如果没有定时器安排，则解除定时器，将 _mkTimerArmed 值置为 false\n            if (rlm->_mkTimerArmed && rlm->_timerPort) {\n                AbsoluteTime dummy;\n                mk_timer_cancel(rlm->_timerPort, &dummy);\n                rlm->_mkTimerArmed = false;\n            }\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n            if (rlm->_dispatchTimerArmed) {\n                _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333);\n                rlm->_dispatchTimerArmed = false;\n            }\n#endif\n        }\n    }\n    // 设置 Runloop Mode 的两个截止时间字段 Deadline\n    rlm->_timerHardDeadline = nextHardDeadline;\n    rlm->_timerSoftDeadline = nextSoftDeadline;\n}\n")])])]),t("p",[e._v("这个方法简单来说就是注册下一个需要触发的 Timer 事件到 Runloop 中。其中有配置 tolerance 的 Timer 会被注册为一个 GCD Timer，未配置 tolerance 的 Timer 截止时间会被注册一个 mach-port 事件，设置到 Runloop Mode 中。")]),e._v(" "),t("h3",{attrs:{id:"触发-timercallback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发-timercallback"}},[e._v("#")]),e._v(" 触发 TimerCallBack")]),e._v(" "),t("p",[e._v("等到 Runloop 被 timer mach-port 唤醒时，调用 __CFRunLoopDoTimers 函数，筛选 _fireTSR 早于当前时刻的 timers：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) {\t/* DOES CALLOUT */\n    Boolean timerHandled = false;\n    CFMutableArrayRef timers = NULL;\n    for (CFIndex idx = 0, cnt = rlm->_timers ? CFArrayGetCount(rlm->_timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm->_timers, idx);\n        if (__CFIsValid(rlt) && !__CFRunLoopTimerIsFiring(rlt)) {\n            if (rlt->_fireTSR <= limitTSR) {\n                // 筛选 _fireTSR 早于当前时刻的 timers\n                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);\n                CFArrayAppendValue(timers, rlt);\n            }\n        }\n    }\n    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx < cnt; idx++) {\n        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);\n        // 筛选后的 timer 依次调用 __CFRunLoopDoTimer\n        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);\n        timerHandled = timerHandled || did;\n    }\n    if (timers) CFRelease(timers);\n    return timerHandled;\n}\n")])])]),t("p",[e._v("接下来 timers 依次调用 __CFRunLoopDoTimer，这个方法中会调用 timer 的任务 rlt->_callout，重新排序 timer，注册下一个 timerPort。")]),e._v(" "),t("h2",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[e._v("#")]),e._v(" 结论")]),e._v(" "),t("p",[e._v("从添加 Timer 到触发 Timer，分析了 Runloop Mode 的数据结构，自始至终 CFRunLoopTimer 都在被 Runloop 管理。NSTimer 对象仅是 Foundation 到 CoreFoundation 衔接的对象，通过 NSTimer 可以匹配操作到 CFRunLoopTimerRef 对象，而 CoreFoundation 的对象已经由底层 CFRetain 和 CFRelease 方法正确 Retain 和 Release。不存在循环引用。")]),e._v(" "),t("h1",{attrs:{id:"end"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#end"}},[e._v("#")]),e._v(" END")])])}),[],!1,null,null,null);n.default=o.exports}}]);