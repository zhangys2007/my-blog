(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{713:function(t,n,a){t.exports=a.p+"assets/img/20200601.9dec4351.png"},745:function(t,n,a){"use strict";a.r(n);var e=a(5),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20200501/20200501.html"}},[t._v("责任链模式")])],1),t._v(" "),e("h2",{attrs:{id:"场景及一般实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景及一般实现"}},[t._v("#")]),t._v(" 场景及一般实现")]),t._v(" "),e("p",[t._v("在使用责任链模式对扫码结果分发这部分代码进行优化之后，我开始思考该场景下还有哪些设计模式比较适用？经过分析思考，觉得策略模式可能也是一剂良药（当然也不是单一的策略模式，还包含了简单工厂模式）。\n策略模式（Strategy）也是一种行为型模式，其定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。")]),t._v(" "),e("h2",{attrs:{id:"uml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uml"}},[t._v("#")]),t._v(" UML")]),t._v(" "),e("hr"),t._v(" "),e("img",{attrs:{src:a(713),width:"80%"}}),t._v(" "),e("ul",[e("li",[t._v("Context：用来操作策略的上下文环境；")]),t._v(" "),e("li",[t._v("Stragety：策略的抽象；")]),t._v(" "),e("li",[t._v("ConcreteStrategy 类：每种策略具体的实现方法。")])]),t._v(" "),e("p",[t._v("对应到上面扫码场景，实际上我们支持的每一种跳转方式都是一种策略，我们拿到扫码结果后根据其内容选择合适的策略即可。")]),t._v(" "),e("h2",{attrs:{id:"代码示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码示例"}},[t._v("#")]),t._v(" 代码示例")]),t._v(" "),e("p",[t._v("直接看整段代码吧，细节看注释")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('// MARK: - 策略的抽象\nprotocol QRCodeScanStrategy {\n     /// 处理抽象方法\n    func deal(info: Any?)\n}\n\n// MARK: - 策略的具体实现\nstruct QRCodeScanLoginStrategy: QRCodeScanStrategy {\n    func deal(info: Any?) {\n        // TODO: - 登录相关逻辑\n    }\n}\n\nstruct QRCodeScanBusinessCardStrategy: QRCodeScanStrategy {\n    func deal(info: Any?) {\n        // TODO: - 加好友相关逻辑\n    }\n}\n\n// MARK: - 用来操作策略的上下文环境\nclass QRCodeScanContext {\n    private var strategy: QRCodeScanStrategy?\n\n    init(type: String) {\n        self.strategy = strategy\n    }\n\n    public func deal(info: Any?) {\n        strategy?.deal(info: info)\n    }\n}\n\n// MARK: - 调用策略\nclass QRCodeScanManager {\n    public static func main() {\n        switch type {\n            case "login":\n                QRCodeScanContext(strategy: QRCodeScanLoginStrategy()).deal(info: ["type": "login", "message": "登录"])\n            case "addContacts"\n                QRCodeScanContext(strategy: QRCodeScanBusinessCardStrategy()).deal(info: ["type": "addContacts", "message": "加好友"])\n            default:\n            break\n        }\n    }\n}\n')])])]),e("p",[t._v("看到上面的代码示例，可能就有读者说了，你这没解决问题啊，if-else还在。\n确实是这样，上述的策略模式只是解决了将每个判断分支里面的逻辑进行了整合，即使用策略模式实现目的一致，但行为不一致的场景，但选用何种策略模式需要额外的控制。\n那接下来我们解决一下if-else的问题，我们主要是要修改一下QRCodeScanContext里面的代码。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('class QRCodeScanContext {\n    private var strategy: QRCodeScanStrategy?\n    /// 根据条件选择合适的Strategy\n    init(type: Sting) {\n        switch type {\n            case "login":\n                strategy = QRCodeScanLoginStrategy()\n            case "addContacts":\n                strategy = QRCodeScanBusinessCardStrategy()\n            default:\n                /// 执行兜底逻辑\n            break\n        }\n    }\n\n    public func deal(info: Any?) {\n        strategy?.deal(info: info)\n    }\n}\n\nclass QRCodeScanManager {\n    public static func main() {\n        let info = ["type": "login", "message": "登录"]\n        if let type = info["type"] as? String {\n            QRCodeScanContext(strategy: type).deal(info: info)\n        }\n    }\n}\n')])])]),e("p",[t._v("如上所示，我们其实是将判断移到了 Context 中去，其实这也算是简单工厂模式的一种体现，当然我们也可以专门新建一个工厂类，将判断逻辑移动到工厂类中去，关于简单工厂模式后面会单独讲，这里就不展开说了。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("ul",[e("li",[t._v("将具体的算法实现从业务逻辑中剥离出来，成为一系列独立算法类，使得它们可以相互替换，以避免使用多重条件判断语句（把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起）。")])]),t._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("ul",[e("li",[t._v("客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。")]),t._v(" "),e("li",[t._v("由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多。")])]),t._v(" "),e("h2",{attrs:{id:"最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),e("p",[t._v("责任链模式，客户端的节点串联需要特别注意，不要出现环形，而且其节点先后顺序最好是按照扫描结果其处理的可能性从大到小，减少节点传递的性能损耗。\n对于两种设计模式，我们肯定都需要提供兜底的跳转方式，如直接显示出扫描结果。")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20200701/20200701.html"}},[t._v("命令模式, 中介者模式, 组合模式")])],1)])}),[],!1,null,null,null);n.default=s.exports}}]);