(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{712:function(n,a,e){n.exports=e.p+"assets/img/20200501.99d5cf59.png"},744:function(n,a,e){"use strict";e.r(a);var t=e(5),r=Object(t.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[t("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20200401/20200401.html"}},[n._v("建造者模式")])],1),n._v(" "),t("h2",{attrs:{id:"场景及一般实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景及一般实现"}},[n._v("#")]),n._v(" 场景及一般实现")]),n._v(" "),t("p",[n._v("有一个场景，想必大家都遇到过，就是扫描不同的二维码根据扫描结果跳转进入到不同的功能页面，如登录、加好友等等。我们拿到结果后需要对内容进行校验，是否是我们需要的信息，然后做一些特殊的处理。比如先判断是不是一个 url 链接，是则打开这个链接，不是的话进行下一种判断，比如是否是项目中的约定的跳转某个功能的信息... 依次下去。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("因代码篇幅，后面代码示例也只体现登录、加好友两个 case。\n")])])]),t("p",[n._v("普通的写法便是通过if-else或者switch-case对条件进行判断继而执行不同的分支。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('func onScanResult(type: String) {\n    switch type {\n        case "login":\n         // TODO 登录的相关逻辑\n        case "addContacts"\n         // TODO 添加联系人的相关逻辑\n\n        // 此处省略99种分支判断\n        ...\n\n        default:\n        break\n\n    }\n}\n')])])]),t("p",[n._v("简单的示例如上所示，那这种方法不好的的地方也显而易见：")]),n._v(" "),t("ul",[t("li",[n._v("代码臃肿：当出现很多种情况需要处理时，会出现很多的 if-else，并且相关的逻辑可能会比较复杂，大量的代码堆积到一个文件中去；")]),n._v(" "),t("li",[n._v("每增加一种处理，就需要改动代码新增一个判断分支；")]),n._v(" "),t("li",[n._v("条件判断的顺序是写死的，如果想改变顺序，只能调整判断分支的前后顺序。")])]),n._v(" "),t("p",[n._v("下面我们看一下利用责任链模式是如何优化这个场景下的代码设计的。")]),n._v(" "),t("h2",{attrs:{id:"责任链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式"}},[n._v("#")]),n._v(" 责任链模式")]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("责任链模式 (Chain Of Responsibility Pattern)是行为模式中的一种，又称职责链模式，将请求沿着一条链传递，直到该链上的某个对象处理它为止，其 UML 图如下所示：")]),n._v(" "),t("img",{attrs:{src:e(712),width:"80%"}}),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("- Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用\n- ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；\n在具体处理者中可以访问链中下一个对象，以便请求的转发。\n")])])]),t("h2",{attrs:{id:"代码示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码示例"}},[n._v("#")]),n._v(" 代码示例")]),n._v(" "),t("p",[n._v("我们就以上面二维码扫描结果分发场景为例子，给出代码示例：\n我们先定义 UML 图中的Handler，其一般是一个抽象类或者接口，那在 swift 中的体现便是一个protocol了。")]),n._v(" "),t("h3",{attrs:{id:"抽象处理者handler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象处理者handler"}},[n._v("#")]),n._v(" 抽象处理者Handler")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("protocol QRCodeScanHandler: AnyObject {\n    var nextHandler: QRCodeScanHandler? { get set }\n\n    @discardableResult\n    func setNext(handler: QRCodeScanHandler) -> QRCodeScanHandler\n\n    /// 这里返回值为bool值，用来标识请求是否被正确处理，供客户端等使用\n    func handle(info: Any?) -> Bool?\n}\n\n// MARK: - 协议的默认实现\nextension QRCodeScanHandler {\n    // 默认设置下一个节点的实现\n    func setNext(handler: QRCodeScanHandler) -> QRCodeScanHandler {\n        nextHandler = handler\n        return handler\n    }\n    // 节点处理的默认实现，默认不实现，直接交由下个节点\n    func handle(info: Any?) -> Bool? {\n        return nextHandler?.handle(info: info)\n    }\n}\n")])])]),t("h3",{attrs:{id:"具体处理者concretehandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体处理者concretehandler"}},[n._v("#")]),n._v(" 具体处理者ConcreteHandler")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('// MARK: - 登录处理者\nclass QRCodeScanLoginHandler: QRCodeScanHandler {\n    var nextHandler: QRCodeScanHandler?\n\n    func handle(info: Any?) -> Bool? {\n        guard let dict = info as? [String: String], let type = dict["type"], type == "login" else {\n            return nextHandler?.handle(info: info)\n        }\n        Log.d("登录码")\n        return true\n    }\n}\n\n// MARK: - 加好友处理者\nclass QRCodeScanBusinessCardHandler: QRCodeScanHandler {\n    var nextHandler: QRCodeScanHandler?\n\n    func handle(info: Any?) -> Bool? {\n        guard let dict = info as? [String: String], let type = dict["type"], type == "businessCard" else {\n            return nextHandler?.handle(info: info)\n        }\n        Log.d("名片码")\n        return true\n    }\n}\n')])])]),t("h3",{attrs:{id:"客户端client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端client"}},[n._v("#")]),n._v(" 客户端Client")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('class QRCodeScanManager {\n    public static func main() {\n        let startHandler = QRCodeScanLoginHandler()\n        startHandler\n        .setNext(handler: QRCodeScanBusinessCardHandler())\n        .setNext(handler: XXX)\n        // 继续下一个节点\n        ...\n\n        //\n        guard let result = startHandler.handle(info: ["type": "login", "message": "登录"]), result else {\n            // TODO: - 每个节点都没有成功处理，执行相关逻辑\n            return\n        }\n    }\n}\n\n\n当然，客户端去生成责任链的方式还有很多种，如数组遍历等，大家根据自己的情况自行选择。\n')])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[n._v("其实责任链模式也可以大致分为两种：")]),n._v(" "),t("ul",[t("li",[n._v("纯责任链模式：一个请求必须被某一个处理者对象所接收。对于具体处理者，要么自己处理要么下发给下一个具体处理者；")]),n._v(" "),t("li",[n._v("不纯责任链模式：一个请求被一个处理者处理了一部分，将剩下的交给下一个具体处理者；")])]),n._v(" "),t("p",[n._v("比如上述扫码结果分发在开始需要对扫描的结果进行统一的校验或认证，那就需要增加一个节点并作为头节点，在处理后校验通过并进入到下一个节点，如果不通过则直接返回，这便是不纯责任链模式的体现。\n那责任链模式还可以应用或已经应用在哪些场景下呢？")]),n._v(" "),t("ul",[t("li",[n._v("推送消息的页面跳转")]),n._v(" "),t("li",[n._v("java 网络请求框架 OkHttp（典型的不纯责任链模式，每经过一层，都加点东西）")]),n._v(" "),t("li",[n._v("...")])]),n._v(" "),t("p",[n._v("总结一下责任链模式的优缺点：")]),n._v(" "),t("h3",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[n._v("#")]),n._v(" 优点")]),n._v(" "),t("ul",[t("li",[n._v("降低耦合度，分离了请求与处理，无须知道是哪个对象处理其请求；")]),n._v(" "),t("li",[n._v("链中的节点对象可以灵活地拆分重组。增加或者删除一个节点，或者改变节点在链中的位置都是轻而易举的事情；我们可以根据业务处理的可能性高低设置节点的先后顺序；")]),n._v(" "),t("li",[n._v("可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递；")]),n._v(" "),t("li",[n._v("扩展容易，新增具体请求处理者，只需要在客户端重新建链即可，无需破坏原代码。")])]),n._v(" "),t("h3",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[n._v("#")]),n._v(" 缺点")]),n._v(" "),t("ul",[t("li",[n._v("没有明确的处理者，请求可能最后都没有被处理。在这种情况下，我们一般需要在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。")]),n._v(" "),t("li",[n._v("较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便；")]),n._v(" "),t("li",[n._v("靠客户端维护节点顺序，如果建链不当，可能会造成循环调用，将导致系统陷入死循环。")])]),n._v(" "),t("h2",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[n._v("#")]),n._v(" 最后")]),n._v(" "),t("p",[n._v("策略模式，我们其实还是需要去判断选用何种策略，那么当判断选用何种策略的逻辑相对复杂的时候实际上还是责任链模式比较适合一些，因为责任链模式可以将判断逻辑全部写在自己内部，每个节点之间相互独立，互不影响。")]),n._v(" "),t("p",[t("RouterLink",{attrs:{to:"/handbook/iOS/2020/设计模式/20200601/20200601.html"}},[n._v("策略模式")])],1)])}),[],!1,null,null,null);a.default=r.exports}}]);